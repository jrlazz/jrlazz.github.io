<!DOCTYPE html>
<html lang="en">
<head>
<title>paintfatB2.html</title>
<meta charset="utf-8">
<link rel="shortcut icon" href="https://threejs.org/files/favicon.ico"/>

<style>
span{position:absolute;font-family:Monospace;font-size:9pt;color:#008;z-index:2;}
body{margin:0px;background-color:#5493de;overflow:hidden;}
input{width:45px;font-size:16pt;font-family:Monospace;background-color:#001144;color:#0ff;border:none;}
@font-face {font-family:tipo;src:url('../fonte/MysteryQuest-Regular.ttf');}
</style>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
    }
  }
</script>

</head>

<body>
<span id="spanA" style="left:10px;top:5px;">right click &rarr; inspect &rarr; source code</span>
<span id="spanB" style="left:10px;top:35px;"></span>
<span id="lets" style="font-family:tipo;font-size:32pt;color:#ff0;top:320px;left:2000px;width:500px;">Mouse down <font style="color:#0f0;">and</font><font style="color:#f9f;"> let's</font><font style="color:#0ff;"> GO !!!</font></span>


<script type="module">

import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import { Line2 } from "three/addons/lines/Line2.js";
import { LineMaterial } from "three/addons/lines/LineMaterial.js";
import { LineGeometry } from "three/addons/lines/LineGeometry.js";
import { SVGLoader } from "three/addons/loaders/SVGLoader.js";

var renderer, scene, camera, controls, color;

var pp=[];for(let r=1;r<400;r++){pp[r]=[];}
var positions=[];for(let r=1;r<400;r++){positions[r]=[];}

var point=new THREE.Vector3();
var spline=[];
var divs,t;
var curvefactor=1;
var klineGeometry=[];
var kline=[];
var kmatLine=[];

var colors=[];
var sub;

var move=0;
var w=0;
var ww=0;
var wcor;
var wwidth;

var mouse=new THREE.Vector2();
var raycaster=new THREE.Raycaster();
var plane;
var intersects;
var planeIntersect=[];

var bgcorant="#ffffff";

var group=new THREE.Group();
var multi=1.1;
var material,geometry,mesh;
var paths=[]; var shapes=[];
var depth, bevelEnabled, starA, starB, starC, starD;
var extrusion=4;

function init(){

	renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setClearColor('#5493de');
	renderer.setSize(window.innerWidth,window.innerHeight);
	document.body.appendChild(renderer.domElement);

	scene=new THREE.Scene();

	camera = new THREE.PerspectiveCamera(40, window.innerWidth/window.innerHeight,1,1000);
	camera.position.set(0,0,30);

	document.addEventListener('mousemove',onMouseMove);
	document.addEventListener("mousedown",onMouseDown);
	document.addEventListener('mouseup',onMouseUp);
/*
	controls=new OrbitControls(camera,renderer.domElement);
	controls.minDistance=10;
	controls.maxDistance=100;
	controls.enablePan=true;
	controls.enableZoom=true;
	controls.enableRotate=true;
	controls.enableDamping=true;
*/

	window.addEventListener('resize',onWindowResize);
	onWindowResize();

starA=new THREE.PointLight("#ff0",0.5); starA.position.set( 90,-30,70);scene.add(starA);
starB=new THREE.PointLight("#f00",0.5); starB.position.set( 25,-30,70);scene.add(starB);
starC=new THREE.PointLight("#f0f",0.5); starC.position.set(-25,-30,70);scene.add(starC);
starD=new THREE.PointLight("#0f0",0.5); starD.position.set(-90,-30,70);scene.add(starD);

var loader=new SVGLoader();
	loader.load("img/train.svg",function(data){
		var paths=data.paths;
		group.scale.multiplyScalar(multi);
		group.position.set(0,0,0);
		group.scale.y *= - 1;
		for(let i=0;i<paths.length;i++){
			material=new THREE.MeshStandardMaterial({color:('#ccc'),metalness:0.5,roughness:0.2});
			shapes=SVGLoader.createShapes(paths[i]);
			for(let j=0;j<shapes.length;j++){
				geometry=new THREE.ExtrudeGeometry(shapes[j],{depth:extrusion,bevelEnabled:false});
				mesh=new THREE.Mesh(geometry,material);
				mesh.scale.set(0.1,0.1,0.1);
				group.add(mesh);
			}
		}
		group.position.set(80,-10,-40);
		group.rotation.set(0,3.14,0);
		scene.add(group);
});


}

function onMouseDown(event){
	wcor=window.parent.ifra.cor;
	if(wcor=="R"){wcor=get_random_color();}
	wwidth=window.parent.ifra.size;
	move=1;
	calc();
	w++;
}

function onMouseMove(event){if(move==1){calc();}}

function onMouseUp(event){move=0;}

function calc(){
	mouse.x=(event.clientX/window.innerWidth)*2-1;
	mouse.y=-(event.clientY/window.innerHeight)*2+1;
	mouse.z=0;
	raycaster=new THREE.Raycaster();
	plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
	raycaster.setFromCamera(mouse,camera);
	intersects=new THREE.Vector3();
	planeIntersect=raycaster.ray.intersectPlane(plane,intersects);
	//document.getElementById("spanB").innerText="("+planeIntersect.x+","+planeIntersect.y+","+planeIntersect.z+")";
}

function get_random_color(){
	color="";
	for(let i=0;i<3;i++){
        	sub=Math.floor(Math.random()*256).toString(16);
        	color +=(sub.length==1?"0"+sub:sub);
    	}
    	return "#"+color;
}

function onWindowResize(){
	camera.aspect=window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

function animate(){
	requestAnimationFrame(animate);
	//controls.update();
	if(move==1){
		scene.remove(kline[w]);
		pp[w][0]=new THREE.Vector2(planeIntersect.x,planeIntersect.y);
		pp[w][1]=new THREE.Vector2(planeIntersect.x,planeIntersect.y);
		spline[w]=new THREE.SplineCurve(pp[w]);
		divs=curvefactor*(pp[w].length-1);
		point[w]=new THREE.Vector3();
		for(let i=0;i<divs;i++){
			t=i/divs;
			spline[w].getPoint(t,point[w]);
			positions[w].push(point[w].x,point[w].y,point[w].z);
		}
		kmatLine[w]=new LineMaterial({color:wcor,linewidth:wwidth});
		kmatLine[w].resolution.set(window.innerWidth,window.innerHeight);
		klineGeometry[w]=new LineGeometry();
		klineGeometry[w].setPositions(positions[w]);
		kline[w]=new Line2(klineGeometry[w],kmatLine[w]);
		scene.add(kline[w]);
	}
	renderer.render(scene,camera);

	if(window.parent.ifra.rota==1){
//alert(window.parent.ifra.rota);
		for(let u=0;u<400;u++){
			if(kline[u]){
				if(window.parent.ifra.rotax==1){
//alert(window.parent.ifra.rota + "   " + window.parent.ifra.rotax);
					kline[u].rotation.x +=0.01;
				}
				if(window.parent.ifra.rotay==1){
					kline[u].rotation.y +=0.01;
				}
				if(window.parent.ifra.rotaz==1){
//alert(window.parent.ifra.rota + "   " + window.parent.ifra.rotaz);
					kline[u].rotation.z +=0.01;
				}
			}
		}
	}

	if(window.parent.ifra.bgcor!=bgcorant){
		renderer.setClearColor(window.parent.ifra.bgcor);
		bgcorant=window.parent.ifra.bgcor;
	}

	if(group && ww<500 && lets){
		group.position.x -=0.5;
		ww++;
		//if(ww==450){alert(ww);}
		document.getElementById("lets").style.left=((screen.availWidth+200)-(ww*6.5)) + "px";
	}
}

init();

animate();

/*

Painting with fat lines 1

Hi Three.js followers,

A better mouse position calculation!

the link:

http://jrlazz.eu5.org/anim/paintfatA1.html

Again, Thanks for the great Three.js Team!

Jose Roberto Lazzareschi

*/

</script>
</body>
</html>
