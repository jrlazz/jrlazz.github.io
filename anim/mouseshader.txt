<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>mouseshader.html</title>
 <style>
@font-face{font-family:myq;src:url('../fonte/MysteryQuest-Regular.ttf');}
body{overflow: hidden;margin:0px;background-color:#024;}
</style>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.171.0/build/three.module.min.js",
      "three/addons/": "https://unpkg.com/three@0.171.0/examples/jsm/"
    }
  }
</script>

</head>
<body>
<span style="position:absolute;width:99%;top:41%;font-family:myq;font-size:41pt;color:#ff0;text-align:center;">Hello... with GPT help...</span>
<button style="position:absolute;left:2%;top:2%;background-color:#c90;text-align:center;"><a id="code" href="mouseshader.txt" target="_blank" style="color:#024;font-weight:bold;text-decoration:none;">The Code</a></button>

<script type="module">
	import * as THREE from 'three';

	const scene = new THREE.Scene();

	const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
	camera.position.z=1;

	const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true});
	renderer.setSize(window.innerWidth, window.innerHeight);
	renderer.setClearColor(0x404040,0);
	document.body.appendChild(renderer.domElement);

	// Vertex Shader
	const vertexShader = `
		varying vec2 vUv;
		void main() {
    		vUv = uv;
    		gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
	}`

	// Fragment Shader
	const fragmentShader = `
	varying vec2 vUv;
	uniform float iTime;
	uniform vec2 iResolution;
	uniform vec2 iMouse;
	void main() {
    		vec2 uv = vUv;
    		uv.x *= iResolution.x / iResolution.y;
		vec3 color = vec3(0.0);
		vec2 mousePos = iMouse / iResolution; // Normalize mouse position
		mousePos.y = 1.0 - mousePos.y; // Invert y-axis for correct UV mapping
		for (int i = 0; i < 128; i++) {
			float pha = sin(float(i) * 546.13 + 1.0) * 0.5 + 0.5;
			float siz = pow(sin(float(i) * 651.74 + 5.0) * 0.5 + 0.5, 4.0);
			float pox = sin(float(i) * 321.55 + 4.1) * iResolution.x / iResolution.y;
			float rad = 0.1 + 0.5 * siz + sin(pha + siz) / 4.0;
			vec2 pos = vec2(
				pox + sin(iTime / 15.0 + pha + siz) + mousePos.x * 2.0 - 1.0,
				-1.0 - rad + (2.0 + 2.0 * rad) * mod(pha + 0.3 * (iTime / 7.0) * (0.2 + 0.8 * siz), 1.0) + mousePos.y
			);
			float dis = length(uv - pos);
			vec3 col = mix(
			vec3(0.194 * sin(iTime / 6.0) + 0.3, 0.2, 0.3 * pha),
			vec3(1.1 * sin(iTime / 9.0) + 0.3, 0.2 * pha, 0.4),
			0.5 + 0.5 * sin(float(i))
			);
			float f = length(uv - pos) / rad;
			f = sqrt(clamp(1.0 + (sin(iTime * siz) * 0.5) * f, 0.0, 1.0));
			color += col.zyx * (1.0 - smoothstep(rad * 0.15, rad, dis));
		}
		color *= sqrt(1.5 - 0.5 * length(uv));
		gl_FragColor = vec4(color, 1.0);
	}`

	const uniforms = {
    	iTime: { value: 0 },
   	 iResolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
    	iMouse: { value: new THREE.Vector2() }, // Add mouse uniform
	};

	const material = new THREE.ShaderMaterial({
	    uniforms: uniforms,
	    vertexShader: vertexShader, // The vertex shader code
	    fragmentShader: fragmentShader // The modified fragment shader code
	})

	var geometry = new THREE.PlaneGeometry(window.innerWidth/200,window.innerHeight/200);
	var mesh = new THREE.Mesh(geometry, material);
	scene.add(mesh);

	function onWindowResize() {
	    camera.aspect = window.innerWidth / window.innerHeight;
	    camera.updateProjectionMatrix();
	    renderer.setSize(window.innerWidth, window.innerHeight);
	}
	window.addEventListener('resize', onWindowResize, false);

	window.addEventListener('mousemove', (event) => {
   	 uniforms.iMouse.value.set(event.clientX, event.clientY);
	});

function animate(){
	    requestAnimationFrame(animate);
	    uniforms.iTime.value += 0.05;
	    renderer.render(scene, camera);
}

animate();

</script>
</body>
</html>
