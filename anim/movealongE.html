<!DOCTYPE html>
<html lang="en">
<head>
<title>movealongE.html</title>
<meta charset="utf-8" />
<link rel="shortcut icon" href="../ok.ico">

<script type="importmap">
{"imports": {"three": "https://cdn.jsdelivr.net/npm/three@0.172.0/build/three.module.min.js",
"three/addons/": "https://cdn.jsdelivr.net/npm/three@0.172.0/examples/jsm/"}}
</script>

<style>
body{margin:0;background-color:#024;font-family:Lucida Console;font-size:9pt;color:#0ff;overflow:hidden;}
td,span{font-family:Lucida Console;font-size:16pt;color:#0ff;}
</style>

</head>

<body>

<table id="tab" style="position:absolute;left:10px;top:60px;display:none;">
<tr><td>fast:</td><td><input id="tval" type="range" value=0.5 min=1 max=4 step=0.5 autocomplete="off" style="width:100px;"></input></td><td><span id="spantval">1</span></td></tr>
</table>

<span id="sp" style="position:absolute;left:20%;right:20%;top:10px;color:#0ff;text-align:center;">
Whoever waits... always reaches...
<!-- <br>https://jsfiddle.net/ne5sx684/ -->
</span>

<script type="module">

import * as THREE from "three"
import { OrbitControls } from "three/addons/controls/OrbitControls.js";
import Stats from "three/addons/libs/stats.module.js";
import { TransformControls } from "three/addons/controls/TransformControls.js";
import { Flow } from "three/addons/modifiers/CurveModifier.js";
import { STLLoader } from 'three/addons/loaders/STLLoader.js';
import { SVGLoader } from 'three/addons/loaders/SVGLoader.js';
import { MTLLoader } from 'three/addons/loaders/MTLLoader.js';
import { OBJLoader } from 'three/addons/loaders/OBJLoader.js';

var scene,camera,renderer,controls,loader,track,curve,stats;
var pointGeometry,pointMaterial,point,iPoints,objectToCurve,handlePos,handle,points,line,geo,mat;

var g=[],l=[],m=[],s=[],flow=[],curveHandles=[],paths=[],shapes=[],ste=[],tex=[];
var ax=[];for(let z=1;z<100;z++){ax[z]=new THREE.AxesHelper(0.05);}
var gro=[];for(let z=1;z<300;z++){gro[z]=new THREE.Group();}
var k=0.0322,kk=0.0322;
var p=Math.PI;
var vel=0.001;
var cT=0.043244;
var currentT=cT;
var arc=0,ini=0,fim=0;
var t=0,sim=0;
var chain=0;
var vector=new THREE.Vector3();
var pStart1,pEnd1,pStart2,pEnd2;
var syn=0;
var synpoint=159990;
var wor=0;
var box1,box2;

var bId=function(id){return document.getElementById(id);}

var dtval=bId("tval");
	dtval.onchange=function TVAL(){
	currentT=cT;
	gro[50].rotation.set(0,0,0);
	for(let z=1;z<125;z=z+1){if(flow[z]){flow[z].moveAlongCurve(-chain);}}
	chain=0;
	gro[50].rotation.set(0,0,0.13);
	gro[51].rotation.set(0,0,0.28);
	u=dtval.value;dspantval.innerText=u;
	dsp.innerText="";syn=0;
}

var dspantval=bId("spantval");
var u=tval.value;
var dsp=bId("sp");
var dtab=bId("tab");

class CurvePositionLabel extends THREE.Group{
	constructor(curve){
		super();
		this.curve=curve;
		this.positionAtT=new THREE.Vector3()
		pointGeometry=new THREE.SphereGeometry();
		pointMaterial=new THREE.MeshBasicMaterial({color:'#f00'});
		point=new THREE.Mesh(pointGeometry,pointMaterial);
		point.scale.setScalar(0.01);
		this.add(point);
	}
	setPositionAtT(t){
		this.curve.getPointAt(t,this.positionAtT);
		this.position.copy(this.positionAtT);
	}
}
		
function init() {
	scene=new THREE.Scene()
	camera=new THREE.PerspectiveCamera(40,window.innerWidth/window.innerHeight,1,1000,)
	camera.position.set(0,0,-3)

	iPoints=[
		{x:1.4,		y:-0.33,	z:0},
		{x:1.6,		y:0,		z:0},
		{x:1.4,		y:0.33,		z:0},
		{x:0,		y:0.6,		z:0},
		{x:-2.04,	y:0.6,		z:0},
		{x:-2.4,	y:0,		z:0},
		{x:-2.04,	y:-0.6,		z:0},
		{x:0,		y:-0.6,		z:0},
	]

	g[0]=new THREE.BoxGeometry(0.02,0.02,0.02);
	m[0]=new THREE.MeshBasicMaterial();
	for(handlePos of iPoints){
		handle=new THREE.Mesh(g[0],m[0]);
		handle.position.copy(handlePos);
		curveHandles.push(handle);
		scene.add(handle);
	}

	curve=new THREE.CatmullRomCurve3(curveHandles.map((handle) => handle.position));
	curve.curveType="centripetal";
	curve.closed=true;

	points=curve.getPoints(100);
	line=new THREE.LineLoop(
		new THREE.BufferGeometry().setFromPoints(points),
		new THREE.LineBasicMaterial({color:'#0f0'}),
	)
	scene.add(line);

	track=new CurvePositionLabel(curve);
	scene.add(track);

	g[2]=new THREE.CylinderGeometry(0.02,0.02,0.6);
	m[2]=new THREE.MeshStandardMaterial({color:'#0f0'});
	s[2]=new THREE.Mesh(g[2],m[2]);
	//scene.add(s[2]);

	g[4]=new THREE.SphereGeometry(0.06,32,32);
	m[4]=new THREE.MeshStandardMaterial({color:'#c0c'});
	s[4]=new THREE.Mesh(g[4],m[4]);
	s[4].position.set(1.67,0,0);
	//scene.add(s[4]);
	
	g[3]=new THREE.SphereGeometry(0.01,16,16);
	m[3]=new THREE.MeshStandardMaterial({color:'#0cc'});
	s[3]=new THREE.Mesh(g[3],m[3]);
	objectToCurve=s[3];
	flow[0]=new Flow(objectToCurve);
	flow[0].updateCurve(0,curve);
	//scene.add(flow[0].object3D);

// ******** ******** STLs
	loader=new STLLoader();
	loader.load( 'models/extras/chainC.stl',function(geometry){
		geometry.scale(0.015,0.015,0.015)
		mat=new THREE.MeshStandardMaterial({color:'#900'});
		objectToCurve=new THREE.Mesh(geometry,mat);
		for(let z=1;z<62;z=z+2){
			flow[z]=new Flow(objectToCurve);
			flow[z].updateCurve(0,curve);
			scene.add(flow[z].object3D);
			flow[z].moveAlongCurve(0.016+k);
			k=k+kk;
		}
	} );
	loader.load('models/extras/chainB.stl',function(geometry){
		geometry.scale(0.015,0.015,0.015)
		mat=new THREE.MeshStandardMaterial({color:'#336'});
		objectToCurve=new THREE.Mesh(geometry,mat);
		k=kk;
		for(let z=2;z<63;z=z+2){
			flow[z]=new Flow(objectToCurve);
			flow[z].updateCurve(0,curve);
			scene.add(flow[z].object3D);
			flow[z].moveAlongCurve(k);
			k=k+kk;
		}
	});
	loader.load('models/extras/chainD.stl',function(geometry){
		geometry.scale(0.015,0.015,0.015)
		mat=new THREE.MeshStandardMaterial({color:'#090'});
		geo=geometry.clone();
		objectToCurve=new THREE.Mesh(geo,mat);
		k=kk;
		for(let z=64;z<125;z=z+2){
			flow[z]=new Flow(objectToCurve);
			flow[z].updateCurve(0,curve);
			scene.add(flow[z].object3D);
			flow[z].moveAlongCurve(0.016+k);
			k=k+kk;
		}
	});


// ******** ******** Gears
	loader=new SVGLoader();
	m[50]=[new THREE.MeshStandardMaterial({color:'#099',metalness:0.7,roughness:0.2}),new THREE.MeshStandardMaterial({color:'#cc0',metalness:0.7,roughness:0.2})];
	loader.load('img/tooth18i2.svg',function(data){
		paths=data.paths;
		shapes=SVGLoader.createShapes(paths[0]);
		g[50]=new THREE.ExtrudeGeometry(shapes[0],{depth:14,curveSegments:10});
		s[50]=new THREE.Mesh(g[50],m[50]);
		s[50].position.set(0,0.33,-0.0025);
		s[50].rotation.set(0,0,p);
		s[50].scale.setScalar(0.0027);
		ax[50].add(s[50]);

		arc=0;	ini=0;	fim=16;
		for(let z=ini;z<fim;z++){
			arc=arc+(p*2)/(fim-1);
			ax[z]=ax[50].clone();
			ax[z].rotation.set(0,0,arc);
			gro[50].add(ax[z]);
		}
		gro[50].rotation.set(0,0,0.13);
		gro[50].position.set(1.24,0,-0.02);
		gro[50].scale.setScalar(1.08);
		//scene.add(gro[50]);

		s[51]=new THREE.Mesh(g[50],m[50]);
		s[51].position.set(0,0.66,0);
		s[51].rotation.set(0,0,p);
		s[51].scale.setScalar(0.0027);
		ax[51].add(s[51]);

		arc=0;	ini=0;	fim=31;
		for(let z=ini;z<fim;z++){
			arc=arc+(p*2)/(fim-1);
			ax[z]=ax[51].clone();
			ax[z].rotation.set(0,0,arc);
			gro[51].add(ax[z]);
		}
		gro[51].rotation.set(0,0,0.28);
		gro[51].position.set(-1.68,0,-0.02);
		gro[51].scale.setScalar(1.055);
		//scene.add(gro[51]);
	})

// ******** ******** Axes
	g[41]=new THREE.CylinderGeometry(0.06,0.06,0.3);
	m[41]=new THREE.MeshStandardMaterial({color:'#933',metalness:0.9,roughness:0.2});
	s[41]=new THREE.Mesh(g[41],m[41]);
	s[41].rotation.set(p/2,0,0);
	s[41].position.set(1.24,0,0);
	//scene.add(s[41]);
		s[42]=s[41].clone();
		s[42].scale.set(2,1,2);
		s[42].position.set(-1.68,0,0);
		//scene.add(s[42]);


// ******** ******** Gear extras
	g[43]=new THREE.CylinderGeometry(0.55,0.55,0.045);
	m[43]=new THREE.MeshStandardMaterial({color:'#099',metalness:0.7,roughness:0.2});
	s[43]=new THREE.Mesh(g[43],m[43]);
	s[43].rotation.set(p/2,0,0);
	s[43].position.set(-1.68,0,0);
	//scene.add(s[43]);
		s[44]=s[43].clone();
		s[44].scale.set(0.5,1,0.5);
		s[44].position.set(1.24,0,0);
		//scene.add(s[44]);

// ******** ******** Pedals
	g[60]=new THREE.CylinderGeometry(0.05,0.05,1);
	m[60]=new THREE.MeshStandardMaterial({color:'#ccc',metalness:0.7,roughness:0.2});
	s[60]=new THREE.Mesh(g[60],m[60]);
	s[60].rotation.set(p/2,0,0);
	s[60].position.set(0,0,0);
		g[61]=new THREE.CylinderGeometry(0.05,0.05,0.5);
		s[61]=new THREE.Mesh(g[61],m[60]);
		s[61].position.set(0,0.25,0.5);
	s[62]=s[61].clone();
	s[62].position.set(0,-0.25,-0.5);
		s[63]=s[60].clone();
		s[63].scale.set(1,0.5,1);
		s[63].position.set(0,-0.5,-0.75);
	s[64]=s[63].clone();
	s[64].scale.set(1,0.5,1);
	s[64].position.set(0,0.5,0.75);

	g[65]=new THREE.SphereGeometry(0.1,32,32);
	s[65]=new THREE.Mesh(g[65],m[60]);
	s[65].position.set(0,0,0.5);
		s[66]=s[65].clone();s[66].position.set(0,   0,-0.5);
		s[67]=s[65].clone();s[67].position.set(0,-0.5,-0.5);
		s[68]=s[65].clone();s[68].position.set(0, 0.5, 0.5);
		s[69]=s[65].clone();s[69].position.set(0, 0.5, 1);
		s[70]=s[65].clone();s[70].position.set(0, 0.5, 0.75);
		s[71]=s[65].clone();s[71].position.set(0,-0.5,-0.75);
		s[72]=s[65].clone();s[72].position.set(0,-0.5,-1);
	
	for(let z=60;z<73;z++){
		if(s[z]){gro[60].add(s[z]);}
	}
	gro[60].position.set(-1.68,0,0);
	//scene.add(gro[60]);


// ******** ******** Body
	for(let z=1;z<63;z++){tex[z]=new THREE.TextureLoader().load('models/skins/ski'+z+'.png');tex[z].colorSpace=THREE.SRGBColorSpace;tex[z].minFilter=THREE.NearestFilter;tex[z].magFilter=THREE.NearestFilter;}
	new MTLLoader().load('models/steve/partesfoscas.mtl',function(mat){mat.preload();new OBJLoader().setMaterials(mat).load('models/steve/separa9.obj',function(object){
	for(let k=0;k<6;k++){if(object.children[k]){ste[k]=object.children[k];ste[k].material=new THREE.MeshStandardMaterial({map:tex[49]});}}});});
	g[10]=new THREE.BoxGeometry(0.2,1,0.5);
	g[10].translate(0,0.5,0);
	g[10].rotateX(p/2);
	m[10]=new THREE.MeshLambertMaterial({color:'#999',map:tex[49]});
	s[10]=new THREE.Mesh(g[10],m[10]);
	//scene.add(s[10]);
		pStart1=new THREE.Vector3();
		g[11]=new THREE.SphereGeometry(0.12);
		s[11]=new THREE.Mesh(g[11],new THREE.MeshBasicMaterial({color:'#444'}));
		s[12]=s[11].clone();
		s[12].scale.set(3,1,2);
		//scene.add(s[11],s[12]);
	pStart1.set(-1.6,2,0.75);
	s[11].position.copy(pStart1);

	s[13]=s[10].clone();
	//scene.add(s[13]);
		pStart2=new THREE.Vector3();
		s[14]=s[11].clone();
		s[15]=s[12].clone();
		//scene.add(s[14],s[15]);
	pStart2.set(-1.6,2,-0.75);
	s[14].position.copy(pStart2);

// ******** ******** Render
	renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
	renderer.setClearColor(0x222222,0);
	renderer.setPixelRatio(window.devicePixelRatio)
	renderer.setClearColor("#FF796c",0)
	renderer.setSize(window.innerWidth, window.innerHeight)

	document.body.appendChild(renderer.domElement)

	controls=new OrbitControls(camera,renderer.domElement);
	
	l[1]=new THREE.AmbientLight('#fff',5);scene.add(l[1]);
	l[3]= new THREE.DirectionalLight('#fff',2);l[3].position.set(-10,10,10);scene.add(l[3]);

	stats=new Stats();document.body.appendChild(stats.dom);

	window.addEventListener("resize",onWindowResize);
}

function onWindowResize(){
	camera.aspect=window.innerWidth/window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth,window.innerHeight);
}

function animate(){
	requestAnimationFrame(animate);

	if (flow[0] && flow[124] && gro[50] && gro[51] && gro[60] && s[2] && s[3]) {
		flow[0].moveAlongCurve(vel*u)
		currentT = (currentT + vel*u) % 1;
		track.setPositionAtT(currentT);
		//console.log(track.position);
		//console.log("x="+track.position.x*100000+" y="+track.position.y*100000);
		s[2].position.set(track.position.x,track.position.y,track.position.z)
		for(let z=1;z<125;z=z+1){if(flow[z]){flow[z].moveAlongCurve(vel*u);}}
		chain +=vel*u;
		gro[50].rotation.z +=(u/38.6);gro[51].rotation.z +=(u/77);gro[60].rotation.z +=(u/77);

		s[2].geometry.computeBoundingBox();
		s[4].geometry.computeBoundingBox();
		s[2].updateMatrixWorld();
		s[4].updateMatrixWorld();
		box1 = s[2].geometry.boundingBox.clone();
		box1.applyMatrix4(s[2].matrixWorld);
		box2 =s[4].geometry.boundingBox.clone();
		box2.applyMatrix4(s[4].matrixWorld);

		dsp.innerText="touch "+box1.intersectsBox(box2);
		if(box1.intersectsBox(box2)==="true"){
			currentT=cT;
			gro[50].rotation.set(0,0,0);
			for(let z=1;z<125;z=z+1){if(flow[z]){flow[z].moveAlongCurve(-chain);}}
			chain=0;
			gro[50].rotation.set(0,0,0.13);
			gro[51].rotation.set(0,0,0.28);
		}

	}

 	gro[60].updateMatrixWorld();
    	vector.setFromMatrixPosition(s[70].matrixWorld);
 	//console.log(gro[60].position,s[70].position, vector);
	//console.log(vector);
	pEnd1=new THREE.Vector3();
	pEnd1.set(vector.x,vector.y,vector.z);
	s[12].position.copy(pEnd1); 
	s[10].position.copy(pStart1);
	s[10].scale.z=pStart1.distanceTo(pEnd1);
	s[10].lookAt(pEnd1);

 	gro[60].updateMatrixWorld();
    	vector.setFromMatrixPosition(s[71].matrixWorld);
	pEnd2=new THREE.Vector3();
	pEnd2.set(vector.x,vector.y,vector.z);
	s[15].position.copy(pEnd2); 
	s[13].position.copy(pStart2);
	s[13].scale.z=pStart2.distanceTo(pEnd2);
	s[13].lookAt(pEnd2);

	if(ste[5] && sim==0){
		for(let z=0;z<6;z++){ste[z].rotateY(p);}
		ste[0].position.set(0,1,0);//CA
		ste[0].scale.set(1,1,1.25);//CA
		ste[3].position.set( 1.1,-0.5,0);//BD
		ste[3].scale.set(1,0.25,1);//BD
		ste[1].position.set(-1.15,-0.5,0);//BE
		ste[1].scale.set(1,0.25,1);//BE
		ste[5].position.set( 1.1,-0.5,0);//PD
		ste[4].position.set( 1.1,-0.5,0);//PE
		ste[2].position.set(-1.6,4.2,0);//TR
		ste[2].rotateY(-p/2);
		ste[2].add(ste[0]);
		ste[2].add(ste[3]);
		ste[2].add(ste[1]);
		ste[2].scale.set(0.8,0.8,0.6);
		scene.add(ste[2]);
		sim=1;
	}

	if(sim==1){
		ste[0].rotation.x -=u/2*vector.y/100;
		scene.add(flow[0].object3D);
		scene.add(s[2],s[4]);
		scene.add(gro[50],gro[51],gro[60]);
		scene.add(s[41],s[42],s[43],s[44]);
		scene.add(s[10],s[11],s[12],s[13],s[14],s[15]);
		dtab.style.display="";
		//dsp.innerText="";
	}

	stats.update();
	renderer.render(scene, camera);
}

init();
animate();
console.clear();

</script>
</body>
</html>